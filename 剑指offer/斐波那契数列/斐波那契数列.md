# 题目一：求斐波那契数列的第n项

> 写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。斐波那契数列的定义如下：


![](http://oqthot1vw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer%20%E9%A2%98%E7%9B%AE10%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%28%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%AE%9A%E4%B9%89%EF%BC%89.png)

## 解法一：效率很低的递归解法

很多C语言教科书在讲述递归函数的时候，都会用斐波那契数列作为例子，代码如下：

```
long Fibonacci(unsigned int n)
{
	if (n <= 0)
		retrun 0;
	if (n == 1)
		retrun 1;
	
	retrun  Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

但这个解法有很严重的效率问题。

我们以求解f(10)为例来分析递归的求解过程。想求得f(10)，需要先求得f(9)和f(8)。同样，相求得f(9)，需要先求得f(8)和f(7)......我们可以用树形结构来表示这种依赖的关系。

我们不难发现，在这棵树中有很多节点都是都是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。事实上，用敌对方法计算的时间复杂度是以n的指数的方式递增的。

## 解法二：循环

其实改进的方法并不复杂。上述递归代码之所以慢，是因为重复的计算太多，我们只要想办法避免重复计算就行了。比如我们可以把已经得到的数列中间项保存起来，在下一次需要计算的时候我们先查找一下，如果前面已经计算过就不用再重复计算了。

更简单的办法是从下往上计算，首先根据f(0)和f(1)算出f(2)，再根据f(1)和f(2)算出f(3)......以此类推就可以算出第n项了。很容易理解，这种思路的时间复杂度是O(n)。代码如下（Java版）：

```
public class Solution {
    public int Fibonacci(int n) {
        int fn1 = 1;
        int fn2 = 1;
        if(n <= 0 ) {
            return 0;
        }
        if(n==1 || n==2) {
            return 1;
        }
        while(n>2) {
            fn2 += fn1;
            fn1 = fn2-fn1;
            n--;
        }
        return fn2;
    }
}
```

# 题目二：青蛙跳台阶问题

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。

首先我们考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种就是一次跳2级。

接着我们再来讨论一般情况。我们吧n级台阶时的跳法看成是n的函数，记为f(n)。当n > 2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此，n级台阶的不同跳数的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。

```
递归解法：
public class Solution {
    public int JumpFloor(int target) {
		if (target <= 0){
		    return 0;
		} else if (target == 1){
		    return 1;
		} else if (target == 2){
		    return 2;
		} else {
		    return JumpFloor(target - 1) + JumpFloor(target - 2);
		}
    }
}
```

```
循环解法：
public class Solution {
    public int JumpFloor(int target) {
        int fn1 = 1;
        int fn2 = 2;
        if(target <= 0 ) {
            return 0;
        } else if(target==1) {
            return 1;
        } else if (target == 2) {
            return 2;
        }
        while(target>2) {
            fn2 += fn1;
            fn1 = fn2-fn1;
            target--;
        }
        return fn2;
    }
}
```
---
测试用例：
- 功能测试（如输出3、5、10等）。
- 边界值测试（如输出0、1、2）。
- 性能测试（输入较大的数字，如40、50、100）.
---

# 题目三：青蛙变态跳台阶问题

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶......它也可以跳上n级台阶，此时改青蛙跳上一个n级的台阶总共有多少种跳法？

我们用数学归纳法可以证明f(n)=2^(n-1)。

分析过程：
f(1) = 1
f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。
f(3) = f(3-1) + f(3-2) + f(3-3) 
...
f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 

说明： 
1. 这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。
2. n = 1时，只有1种跳法，f(1) = 1
3. n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 
4. n = 3时，会有三种跳得方式，1阶、2阶、3阶，
    那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)
    因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)
5. n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论：
    f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) => f(0) + f(1) + f(2) + f(3) + ... + f(n-1)
    
6. 由以上已经是一种结论，但是为了简单，我们可以继续简化：
    f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)
    f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)
    可以得出：
    f(n) = 2*f(n-1)
    
7. 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为：
![](http://oqthot1vw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer%20%E9%A2%98%E7%9B%AE10%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%28%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%EF%BC%89.png)

代码如下：

```
public class Solution {
    public int JumpFloorII1(int target) {
        if (target <= 0){
            return -1;
        } else {
            return (int)Math.pow(2, target - 1);
        }
        // return 1 << (target - 1);
    }

    public int JumpFloorII2(int target) {
        if (target <= 0){
            return -1;
        } else if (target == 1){
            return 1;
        } else {
            return 2 * JumpFloorII2(target - 1);
        }
    }
}
```

# 拓展

我们可以用2×1的小矩形横着或者竖着去覆盖更大的矩形。请问8个2×1的小矩形无重叠地覆盖一个2×8的大矩形，总共有多少种方法？

![](http://oqthot1vw.bkt.clouddn.com/%E5%89%91%E6%8C%87offer%20%E9%A2%98%E7%9B%AE10%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%88%E4%B8%80%E4%B8%AA%202x1%20%E7%9A%84%E7%9F%A9%E9%98%B5%E5%92%8C%202x8%20%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%89.png)

我们先把2×8的覆盖方法记为f(8)。用第一个2×1的小矩形去覆盖大矩形的最左边时有两种选择：横着放或者竖着放。当横着放的时候，右边还剩下2×7的区域，这种情形下的覆盖方法记为f(7)。接下来考虑横着放的情况。当2×1的小矩形横着放在左上角的时候，左下角必须也横着放一个2×1的小矩形，而在右边还剩下2×6的区域，这种情形下的覆盖方法记为f(6)，因此f(8) = f(7) + f(6)。此时我们可以看出，这仍然是斐波那契数列。