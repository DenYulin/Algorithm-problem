# 题目：链表中倒数第K个节点

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6 。这个链表的倒数第3个节点是值为4的节点。链表的节点定义如下：

```
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
```

## 简单的做法，遍历两次

假设整个链表有n个节点，那么倒数第k个节点就是从头节点开始的第n-k+1个节点。如果我们能够获得到链表中节点的个数n，那么只需要从头节点开始往后走n-k+1步就可以了。只需要从头开始遍历链表，没经过一个节点，计算器加1就能得到n。

也就是说我们要遍历两次链表，第一次统计出链表中节点的个数，第二次找出倒数第k个节点。

# 只遍历一次的解法

我们先定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针距离保持在k-1，当第一个（走在前面的）指针到达链表的尾节点时，第二个（走在后面的）指针正好指向倒数第k个节点。

但需要考虑一下三种特殊情况：
- 输入的head为空指针。
- 输入的以head为头结点的链表的节点总数少于k。
- 输入的参数k为0。

```
// 解法一
class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
public class Solution {

    public ListNode FindKthToTail(ListNode head,int k) {

        if (k <= 0 || head == null){
            return null;
        }

        int count = 1;
        ListNode node = head;
        while (head != null && head.next != null){
            if (k <= count){
                node = node.next;
                head = head.next;
                count++;
            } else{
                head = head.next;
                count++;
            }
        }
        if (count < k){
            return null;
        }
        return node;
    }
}
```

---
测试用例：
- 功能测试（第k个节点在链表的中间；第第k个节点是链表的头节点；k个节点是链表的尾节点）
- 特殊输入测试（链表头节点为null指针；链表的节点总数少于k；k等于0）
---

## 相关题目

求链表的中间节点，如果链表中的节点总数为奇数，则返回中间的节点，如果节点总数是偶数，则返回中间两个节点的任意一个，为了解决这个问题，我们也可以定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在链表的中间

## 举一反三

但我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。可以让其中一个指针遍历的速度快一些（比如一次在链表上走两步），或者让它先在链表上先走若干步。