# 题目：剪绳子

> 给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n>1 并且 m>1），每段绳子的长度记为k[0]、k[1]、k[2]、...、k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

这里有两种解决方法，分别为

- 常规的需要O(n^2)时间和O(n)空间的动态规划的方法
- 只需要O(1)时间和空间的贪婪算法

## 动态规划方法

首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀的时候，我们有n-1中可能的选择，也就是剪出来的第一段绳子的可能长度 分别为1,2,...,n-1。因此f(n)=max(f(i)×f(n-i)),其中0<i<n。

这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从而有大量不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2)、f(3)，再得到f(4)、f(5)，直到得到f(n)。

当绳子的长度为2时，只可能剪成长度都为1的两段，因此f(2)等于1.当绳子的长度为3时，可能把绳子剪成长度分别为1和2的两段或者长度都为1的三段，由于1×2 > 1×1×1，因此f(3)=2。

```
int maxProductAfterCutting_solution1(int length) 
{
	if (length < 2) 
		return 0;
	if (length == 2)
		return 1;
	if (length == 3)
		return 2;

	int* products = new int[length + 1];
	products[0] = 0;
	products[1] = 1;
	products[2] = 2;
	products[3] = 3;

	int max = 0;

	for (int i = 4; i <= length; ++i) 
	{
		max = 0;
		for (int j = 1; j <= i/2; ++j) {
			int product = products[j] * products[i - j];
			if (max < product) 
				max = product;
			products[i] = max;
		}
	}

	max = products[length];
	delete[] products;
	return max;
}
```
在上述代码中，子问题的最优解存在数组products里。数组中第i个元素表示把长度为i的绳子剪成若干段之后各段长度乘积的最大值，即f(i)。我们注意带代码中第一个for循环变量i是顺序递增的，这意味着计算顺序是自下而上的。并且结果保存在products[j]里。为了求解f(i),我们需要求出所有可能的f(j)×f(i - j)并比较得出它们的最大值。这就是代码中第二个for循环的功能。

## 贪婪算法

如果我们按照如下的策略来剪绳子，则得到的各段绳子的长度的乘积将最大：当n>=5时，我们尽可能多地剪成长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。这种思路对应的参考代码如下：
```
int maxProductAfterCutting_solution2(int length) 
{
	if (length < 2)
		return 0;
	if (length == 2)
		return 1;
	if (length == 3)
		return 2;

	// 尽可能多地区剪去长度为3的绳子段
	int timesOf3 = length / 3;

	// 当绳子最后剩下的长度为4的时候，不能再减去长度为3的绳子段。
	// 此时更好的方法是把绳子剪去长度为2的两段，因为 2 × 2 > 3 × 1
	
	if (length - timesOf3 * 3 == 1) {
		timesOf3 -= 1;
	}
	int timesOf2 = (length - timesOf3 * 3) / 2;

	return (int) (pow(3, timesOf3)) * (int)(pow(2, timesOf2));
}
```

### 证明

首先，当n >= 5 的时候，我们可以证明2(n-2)>n 并且 3(n-3)>n。也就是说，当绳子剩下的长度大于或者等于5的时候，我们就把它剪成长度为3或者2的绳子段。另外，当n>=5时，3(n-3) >= 2(n-2),因此我们应该尽可能多地剪成长度为3的绳子段。

那么当绳子的长度为4呢？在长度为4的绳子上剪一刀，有两种可能的结果：剪成长度分别为1和3的两根绳子，或者两根长度都为2的绳子。注意2×2 > 1×3，同时2×2=4，也就是说，当绳子长度为4时其实没必要剪，只是题目的要求至少要剪一刀。

---
测试用例
- 功能测试（绳子的初始长度大于5）
- 边界值测试（绳子的初始长度分别为0、1、2、3、4）
---