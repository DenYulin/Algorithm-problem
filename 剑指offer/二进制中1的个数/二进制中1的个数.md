# 题目：二进制中1的个数

> 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如：把9表示成二进制是1001，有2位是1 。因此，如果输入9，则该函数输出2 。

## 可能引起死循环的解法

先判断整数二进制表示中最右边以为是不是1；接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移动到最右边了，再判断是不是1；这样每次移动一位，直到整个整数变成0为止。

现在的问题变成了怎么判断一个整数的最右边是不是1 。

这很简单，只要把整数和1做位与运算看结果是不是0就知道了。1除最右边的一位之外所有位都是0 。如果一个整数与1做与运算的结果是1，则表示该整数最右边以为是1，否则是0 。

```
public class Solution {
    public int NumberOf1(int number)
    {
        int count = 0;
        while(number != 0) {
            if ((number & 1) == 1) {
                ++count;
            }
            number = number >> 1;
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(new Solution().NumberOf1(-5));
    }

}
```

**问题来了**：

1. 把整数右移一位和把整除除以2在数学上是等价的，那么上面的代码中可以把右移运算换成除以2吗？

不可以，因为出发的效率比移位运算低很多，在实际编程中应尽可能地用移位运算符代替乘除法。

2. 上面的函数如果输入一个负数，比如0x80000000，则运行的结果会是什么?

当把负数0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变成0x4000000，而是0xC000000 。这是因为移位前世一个负数，仍然要保证移位后是一个负数，因此移位后的最高位会设为1。如果一直做右移运算，那么最终这个数字就会变成0xFFFFFFFF而陷入死循环。

## 常规解法

为了避免死循环，我们可以不右移输入的的数字n。首先把n和1做与运算，判断n的最低位是不是为1。 接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1......这样反复左移，每次都能判断n的其中一位是不是1 。

```
public class Solution {
    public int NumberOf1(int number)
    {
        int count = 0;
        int flag = 1;
        while(flag != 0) {
            if ((number & flag) != 0) {
                ++count;
            }
            flag = flag << 1;
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(new Solution().NumberOf1(Integer.MIN_VALUE));
    }

}
```

这个解法中，循环的次数等于整数二进制的位数，32位的整数需要循环32次。


## 更好的解法

如果一个整数不等于0，那么该整数的二进制表示中至少有一位是1 。先假设这个数的最右边一位是1，那么减去1时，最后一位变成0而其他所有位都保持不变。也就是最后一位相当于做了取反操作，由1变成0 。

现在假设最后一位是0。如果该整数的二进制表示中最右边的1位于第m位，那么减去1时，第m位由1变成0，而第m位之后的所有0都变成1，整数中第m位之前的所有位都保持不变。

在前两种情况中，我们发现把一个整数减去1，都是把最右边的1变为0。如果它的右边还有0，则把所有0变为1，而它左边的所有位都保持不变。接下来我们把一个整数和它减去1的结果做位运算，就相当于把它最有边的1变成0 。

**总结**：把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。

```
    public int NumberOf1(int number)
    {
        int count = 0;
        while(number != 0) {
            ++count;
            number = (number - 1) & number;
        }
        return count;
    }
```

---
测试用例
- 正数（包括边界值1、0x7FFFFFFF）
- 负数（包括边界值0x80000000、0xFFFFFFFF）
- 0
---